"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const fs_1 = require("fs");
const path_1 = require("path");
/** @internal */
class LoggerHelper {
    static cleanUpFilePath(fileName) {
        return fileName == null
            ? fileName
            : Object.entries(fileName.split(path_1.sep))
                .reduce((cleanFileName, fileNamePart) => fileNamePart[1] !== LoggerHelper.cwdArray[fileNamePart[0]]
                ? (cleanFileName += path_1.sep + fileNamePart[1])
                : cleanFileName, "")
                .substring(1);
    }
    static isError(e) {
        // An error could be an instance of Error while not being a native error
        // or could be from a different realm and not be instance of Error but still
        // be a native error.
        return (util_1.types === null || util_1.types === void 0 ? void 0 : util_1.types.isNativeError) != null
            ? util_1.types.isNativeError(e)
            : e instanceof Error;
    }
    static getCallSites(error, cleanUp = true) {
        const _prepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = (_, stack) => stack;
        const stack = error == null
            ? new Error().stack.slice(1)
            : error.stack;
        Error.prepareStackTrace = _prepareStackTrace;
        return cleanUp === true
            ? stack.reduce((cleanedUpCallsites, callsite) => {
                var _a, _b, _c;
                if ((callsite === null || callsite === void 0 ? void 0 : callsite.getFileName()) != null &&
                    (callsite === null || callsite === void 0 ? void 0 : callsite.getFileName()) !== "" &&
                    ((_a = callsite === null || callsite === void 0 ? void 0 : callsite.getFileName()) === null || _a === void 0 ? void 0 : _a.indexOf("internal/")) !== 0 &&
                    ((_b = callsite === null || callsite === void 0 ? void 0 : callsite.getFileName()) === null || _b === void 0 ? void 0 : _b.indexOf("module.js")) !== 0 &&
                    ((_c = callsite === null || callsite === void 0 ? void 0 : callsite.getFileName()) === null || _c === void 0 ? void 0 : _c.indexOf("bootstrap_node.js")) !== 0) {
                    cleanedUpCallsites.push(callsite);
                }
                return cleanedUpCallsites;
            }, [])
            : stack;
    }
    static toStackFrameObject(stackFrame) {
        var _a, _b;
        const filePath = stackFrame.getFileName();
        return {
            filePath: (_a = LoggerHelper.cleanUpFilePath(filePath)) !== null && _a !== void 0 ? _a : "",
            fullFilePath: filePath !== null && filePath !== void 0 ? filePath : "",
            fileName: path_1.basename((_b = stackFrame.getFileName()) !== null && _b !== void 0 ? _b : ""),
            lineNumber: stackFrame.getLineNumber(),
            columnNumber: stackFrame.getColumnNumber(),
            isConstructor: stackFrame.isConstructor(),
            functionName: stackFrame.getFunctionName(),
            typeName: stackFrame.getTypeName(),
            methodName: stackFrame.getMethodName(),
        };
    }
    static errorToJsonHelper() {
        if (!("toJSON" in Error.prototype))
            /* eslint-disable */
            Object.defineProperty(Error.prototype, "toJSON", {
                /* eslint-enable */
                value: function () {
                    return Object.getOwnPropertyNames(this).reduce((alt, key) => {
                        alt[key] = this[key];
                        return alt;
                    }, {});
                },
                configurable: true,
                writable: true,
            });
    }
    static overwriteConsole($this, handleLog) {
        ["log", "debug", "info", "warn", "trace", "error"].forEach((name) => {
            console[name] = (...args) => {
                const loglevelMapping = {
                    log: "silly",
                    trace: "trace",
                    debug: "debug",
                    info: "info",
                    warn: "warn",
                    error: "error",
                };
                return handleLog.apply($this, [
                    loglevelMapping[name.toLowerCase()],
                    args,
                ]);
            };
        });
    }
    static colorizeJson(json, chalk, colors, indent = false) {
        const chalkColors = {
            number: chalk.hex(colors.number),
            key: chalk.hex(colors.key),
            string: chalk.hex(colors.string),
            boolean: chalk.hex(colors.boolean),
            null: chalk.hex(colors.null),
        };
        let stringifiedJson = typeof json === "string" ? json : "";
        if (typeof json !== "string") {
            stringifiedJson =
                indent === true
                    ? JSON.stringify(json, undefined, 2)
                    : JSON.stringify(json);
            stringifiedJson =
                stringifiedJson === "{}" ? util_1.format(json) : stringifiedJson;
        }
        return stringifiedJson.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
            let cls = "number";
            if (/^"/.test(match)) {
                if (/:$/.test(match)) {
                    cls = "key";
                }
                else {
                    cls = "string";
                }
            }
            else if (/true|false/.test(match)) {
                cls = "boolean";
            }
            else if (/null/.test(match)) {
                cls = "null";
            }
            return chalkColors[cls](match);
        });
    }
    /*
    import { createReadStream, readFileSync } from "fs";
    import { createInterface, Interface } from "readline";
    public static async _getCodeFrameAsync(
      filePath: string,
      lineNumber: number | null,
      columnNumber: number | null,
      linesBeforeAndAfter: number
    ): Promise<ICodeFrame | undefined> {
      try {
        const fileStream: NodeJS.ReadableStream = createReadStream(filePath, {
          encoding: "utf-8",
        });
        const rl: Interface = createInterface({
          input: fileStream,
          crlfDelay: Infinity,
        });
  
        if (lineNumber != null) {
          const linesBefore: string[] = [];
          let relevantLine: string | undefined;
          const linesAfter: string[] = [];
          let i: number = 0;
          rl.on("line", (line) => {
            if (i < lineNumber && i >= lineNumber - linesBeforeAndAfter) {
              linesBefore.push(line);
            } else if (i === lineNumber) {
              relevantLine = line;
            } else if (i > lineNumber && i <= lineNumber + linesBeforeAndAfter) {
              linesAfter.push(line);
            }
            i++;
          });
          rl.on("close", () => {
            const firstLineNumber: number =
              lineNumber - linesBeforeAndAfter < 0
                ? 0
                : lineNumber - linesBeforeAndAfter;
            return {
              firstLineNumber,
              lineNumber,
              columnNumber,
              linesBefore,
              relevantLine,
              linesAfter,
            };
          });
        }
      } catch {
        return undefined;
      }
    }
    */
    static _getCodeFrame(filePath, lineNumber, columnNumber, linesBeforeAndAfter) {
        var _a;
        const lineNumberMinusOne = lineNumber - 1;
        const file = (_a = fs_1.readFileSync(filePath, { encoding: "utf-8" })) === null || _a === void 0 ? void 0 : _a.split("\n");
        const startAt = lineNumberMinusOne - linesBeforeAndAfter < 0
            ? 0
            : lineNumberMinusOne - linesBeforeAndAfter;
        const endAt = lineNumberMinusOne + linesBeforeAndAfter > file.length
            ? file.length
            : lineNumberMinusOne + linesBeforeAndAfter;
        const codeFrame = {
            firstLineNumber: startAt + 1,
            lineNumber,
            columnNumber,
            linesBefore: [],
            relevantLine: "",
            linesAfter: [],
        };
        for (let i = startAt; i < lineNumberMinusOne; i++) {
            if (file[i] != null) {
                codeFrame.linesBefore.push(file[i]);
            }
        }
        codeFrame.relevantLine = file[lineNumberMinusOne];
        for (let i = lineNumberMinusOne + 1; i <= endAt; i++) {
            if (file[i] != null) {
                codeFrame.linesAfter.push(file[i]);
            }
        }
        return codeFrame;
    }
    static lineNumberTo3Char(lineNumber) {
        return lineNumber < 10
            ? `00${lineNumber}`
            : lineNumber < 100
                ? `0${lineNumber}`
                : `${lineNumber}`;
    }
}
exports.LoggerHelper = LoggerHelper;
LoggerHelper.cwdArray = process.cwd().split(path_1.sep);
//# sourceMappingURL=LoggerHelper.js.map