"use strict";
/**
 * Expressive TypeScript Logger for Node.js
 * @packageDocumentation
 */
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const os_1 = require("os");
const path_1 = require("path");
const source_map_support_1 = require("source-map-support");
const chalk = require("chalk");
const LoggerHelper_1 = require("./LoggerHelper");
/**
 * 📝 Expressive TypeScript Logger for Node.js
 * @public
 */
class Logger {
    /**
     * @param settings - Configuration of the logger instance  (all settings are optional with sane defaults)
     */
    constructor(settings) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        this._logLevels = [
            "silly",
            "trace",
            "debug",
            "info",
            "warn",
            "error",
            "fatal",
        ];
        this._ignoreStackLevels = 3;
        this._attachedTransports = [];
        this._minLevelToStdErr = 4;
        const displayInstanceName = (settings === null || settings === void 0 ? void 0 : settings.displayInstanceName) === true;
        this.settings = {
            displayInstanceName: displayInstanceName,
            instanceName: displayInstanceName
                ? (_a = settings === null || settings === void 0 ? void 0 : settings.instanceName) !== null && _a !== void 0 ? _a : os_1.hostname() : undefined,
            name: (_b = settings === null || settings === void 0 ? void 0 : settings.name) !== null && _b !== void 0 ? _b : "",
            minLevel: (_c = settings === null || settings === void 0 ? void 0 : settings.minLevel) !== null && _c !== void 0 ? _c : "silly",
            logAsJson: (_d = settings === null || settings === void 0 ? void 0 : settings.logAsJson) !== null && _d !== void 0 ? _d : false,
            exposeStack: (_e = settings === null || settings === void 0 ? void 0 : settings.exposeStack) !== null && _e !== void 0 ? _e : false,
            exposeErrorCodeFrame: (_f = settings === null || settings === void 0 ? void 0 : settings.exposeErrorCodeFrame) !== null && _f !== void 0 ? _f : true,
            exposeErrorCodeFrameLinesBeforeAndAfter: (_g = settings === null || settings === void 0 ? void 0 : settings.exposeErrorCodeFrameLinesBeforeAndAfter) !== null && _g !== void 0 ? _g : 5,
            suppressStdOutput: (_h = settings === null || settings === void 0 ? void 0 : settings.suppressStdOutput) !== null && _h !== void 0 ? _h : false,
            overwriteConsole: (_j = settings === null || settings === void 0 ? void 0 : settings.overwriteConsole) !== null && _j !== void 0 ? _j : false,
            logLevelsColors: (_k = settings === null || settings === void 0 ? void 0 : settings.logLevelsColors) !== null && _k !== void 0 ? _k : {
                0: "#B0B0B0",
                1: "#FFFFFF",
                2: "#63C462",
                3: "#2b98ba",
                4: "#CE8743",
                5: "#EE444C",
                6: "#900000",
            },
            jsonHighlightColors: (_l = settings === null || settings === void 0 ? void 0 : settings.jsonHighlightColors) !== null && _l !== void 0 ? _l : {
                number: "#FF6188",
                key: "#A9DC76",
                string: "#FFD866",
                boolean: "#FC9867",
                null: "#AB9DF2",
            },
            stdOut: (_m = settings === null || settings === void 0 ? void 0 : settings.stdOut) !== null && _m !== void 0 ? _m : process.stdout,
            stdErr: (_o = settings === null || settings === void 0 ? void 0 : settings.stdErr) !== null && _o !== void 0 ? _o : process.stderr,
        };
        LoggerHelper_1.LoggerHelper.errorToJsonHelper();
        if (this.settings.overwriteConsole) {
            LoggerHelper_1.LoggerHelper.overwriteConsole(this, this._handleLog);
        }
    }
    /**
     *  Attaches external Loggers, e.g. external log services, file system, database
     *
     * @param transportLogger - External logger to be attached. Must implement all log methods.
     * @param minLevel        - Minimum log level to be forwarded to this attached transport logger. (e.g. debug)
     */
    attachTransport(transportLogger, minLevel = "silly") {
        this._attachedTransports.push({
            minLevel,
            transportLogger,
        });
    }
    /**
     * Logs a silly message.
     * @param args  - Multiple log attributes that should be logged out.
     */
    silly(...args) {
        return this._handleLog.apply(this, ["silly", args]);
    }
    /**
     * Logs a trace message.
     * @param args  - Multiple log attributes that should be logged out.
     */
    trace(...args) {
        return this._handleLog.apply(this, ["trace", args, true]);
    }
    /**
     * Logs a debug message.
     * @param args  - Multiple log attributes that should be logged out.
     */
    debug(...args) {
        return this._handleLog.apply(this, ["debug", args]);
    }
    /**
     * Logs an info message.
     * @param args  - Multiple log attributes that should be logged out.
     */
    info(...args) {
        return this._handleLog.apply(this, ["info", args]);
    }
    /**
     * Logs a warn message.
     * @param args  - Multiple log attributes that should be logged out.
     */
    warn(...args) {
        return this._handleLog.apply(this, ["warn", args]);
    }
    /**
     * Logs an error message.
     * @param args  - Multiple log attributes that should be logged out.
     */
    error(...args) {
        return this._handleLog.apply(this, ["error", args]);
    }
    /**
     * Logs a fatal message.
     * @param args  - Multiple log attributes that should be logged out.
     */
    fatal(...args) {
        return this._handleLog.apply(this, ["fatal", args]);
    }
    _handleLog(logLevel, logArguments, doExposeStack = this.settings.exposeStack) {
        const logObject = this._buildLogObject(logLevel, logArguments, doExposeStack);
        if (!this.settings.suppressStdOutput &&
            logObject.logLevelId >= this._logLevels.indexOf(this.settings.minLevel)) {
            if (!this.settings.logAsJson) {
                this._printPrettyLog(logObject);
            }
            else {
                this._printJsonLog(logObject);
            }
        }
        this._attachedTransports.forEach((transport) => {
            if (logObject.logLevelId >=
                Object.values(this._logLevels).indexOf(this.settings.minLevel)) {
                transport.transportLogger[logLevel](logObject);
            }
        });
        return logObject;
    }
    _buildLogObject(logLevel, logArguments, doExposeStack = true) {
        var _a;
        const callSites = LoggerHelper_1.LoggerHelper.getCallSites();
        const relevantCallSites = callSites.splice(this._ignoreStackLevels);
        const stackFrame = source_map_support_1.wrapCallSite(relevantCallSites[0]);
        const stackFrameObject = LoggerHelper_1.LoggerHelper.toStackFrameObject(stackFrame);
        const logObject = {
            instanceName: this.settings.instanceName,
            loggerName: (_a = this.settings.name) !== null && _a !== void 0 ? _a : "",
            date: new Date(),
            logLevel: logLevel,
            logLevelId: this._logLevels.indexOf(logLevel),
            filePath: stackFrameObject.filePath,
            fullFilePath: stackFrameObject.fullFilePath,
            fileName: stackFrameObject.fileName,
            lineNumber: stackFrameObject.lineNumber,
            columnNumber: stackFrameObject.columnNumber,
            isConstructor: stackFrameObject.isConstructor,
            functionName: stackFrameObject.functionName,
            typeName: stackFrameObject.typeName,
            methodName: stackFrameObject.methodName,
            argumentsArray: [],
        };
        logArguments.forEach((arg) => {
            var _a;
            if (arg != null && typeof arg === "object" && LoggerHelper_1.LoggerHelper.isError(arg)) {
                const errorStack = LoggerHelper_1.LoggerHelper.getCallSites(arg);
                const errorObject = JSON.parse(JSON.stringify(arg));
                errorObject.name = (_a = errorObject.name) !== null && _a !== void 0 ? _a : "Error";
                errorObject.isError = true;
                errorObject.stack = this._toStackObjectArray(errorStack);
                const errorCallSite = LoggerHelper_1.LoggerHelper.toStackFrameObject(source_map_support_1.wrapCallSite(errorStack[0]));
                if (this.settings.exposeErrorCodeFrame &&
                    errorCallSite.lineNumber != null) {
                    errorObject.codeFrame = LoggerHelper_1.LoggerHelper._getCodeFrame(errorCallSite.fullFilePath, errorCallSite.lineNumber, errorCallSite.columnNumber, this.settings.exposeErrorCodeFrameLinesBeforeAndAfter);
                }
                logObject.argumentsArray.push(errorObject);
            }
            else {
                logObject.argumentsArray.push(arg);
            }
        });
        if (doExposeStack) {
            logObject.stack = this._toStackObjectArray(relevantCallSites);
        }
        return logObject;
    }
    _toStackObjectArray(jsStack) {
        const stackFrame = Object.values(jsStack).reduce((stackFrameObj, callsite) => {
            stackFrameObj.push(LoggerHelper_1.LoggerHelper.toStackFrameObject(source_map_support_1.wrapCallSite(callsite)));
            return stackFrameObj;
        }, []);
        return stackFrame;
    }
    _printPrettyLog(logObject) {
        const std = logObject.logLevelId < this._minLevelToStdErr
            ? this.settings.stdOut
            : this.settings.stdErr;
        const nowStr = logObject.date
            .toISOString()
            .replace("T", " ")
            .replace("Z", "");
        const hexColor = this.settings.logLevelsColors[logObject.logLevelId];
        std.write(chalk `{grey ${nowStr}}\t`);
        std.write(chalk.hex(hexColor).bold(` ${logObject.logLevel.toUpperCase()}\t`));
        const functionName = logObject.isConstructor
            ? ` ${logObject.typeName}.constructor`
            : logObject.methodName != null
                ? ` ${logObject.typeName}.${logObject.methodName}`
                : logObject.functionName != null
                    ? ` ${logObject.functionName}`
                    : "";
        const instanceName = this.settings.instanceName != null
            ? `@${this.settings.instanceName} `
            : "";
        std.write(chalk `{grey [${logObject.loggerName}${instanceName}${logObject.filePath}:${logObject.lineNumber}${functionName}]}\t`);
        logObject.argumentsArray.forEach((argument) => {
            const errorArgument = argument;
            if (typeof argument === "object" && !errorArgument.isError) {
                std.write("\n" +
                    LoggerHelper_1.LoggerHelper.colorizeJson(argument !== null && argument !== void 0 ? argument : "", chalk, this.settings.jsonHighlightColors, true) +
                    " ");
            }
            else if (typeof argument === "object" && errorArgument.isError) {
                std.write(chalk.bgHex("AA0A0A").bold(`\n ${errorArgument.name} `) +
                    `  ${util_1.format(errorArgument.message)}\n`);
                this._printPrettyStack(std, errorArgument.stack);
                if (errorArgument.codeFrame != null) {
                    this._printPrettyCodeFrame(std, errorArgument.codeFrame);
                }
            }
            else {
                std.write(util_1.format(argument) + " ");
            }
        });
        std.write("\n");
        if (logObject.stack != null) {
            std.write(chalk `{underline.bold log stack:\n}`);
            this._printPrettyStack(std, logObject.stack);
        }
    }
    _printPrettyStack(std, stackObjectArray) {
        std.write("\n");
        Object.values(stackObjectArray).forEach((stackObject) => {
            var _a;
            std.write(chalk `    {grey •} {yellowBright ${stackObject.fileName}}{grey :}{yellow ${stackObject.lineNumber}} {white ${(_a = stackObject.functionName) !== null && _a !== void 0 ? _a : "<anonymous>"}}`);
            std.write("\n    ");
            std.write(path_1.normalize(chalk `{grey ${stackObject.filePath}:${stackObject.lineNumber}:${stackObject.columnNumber}}`));
            std.write("\n\n");
        });
    }
    _printPrettyCodeFrame(std, codeFrame) {
        std.write(chalk `{underline.bold code frame:\n}`);
        let lineNumber = codeFrame.firstLineNumber;
        codeFrame.linesBefore.forEach((line) => {
            std.write(chalk `  ${LoggerHelper_1.LoggerHelper.lineNumberTo3Char(lineNumber)} | ${line}\n`);
            lineNumber++;
        });
        std.write(chalk `{red >} {bgRed.whiteBright ${LoggerHelper_1.LoggerHelper.lineNumberTo3Char(lineNumber)}} | {yellow ${codeFrame.relevantLine}}\n`);
        lineNumber++;
        if (codeFrame.columnNumber != null) {
            const positionMarker = new Array(codeFrame.columnNumber + 8).join(" ") + chalk `{red ^}`;
            std.write(`${positionMarker}\n`);
        }
        codeFrame.linesAfter.forEach((line) => {
            std.write(chalk `  ${LoggerHelper_1.LoggerHelper.lineNumberTo3Char(lineNumber)} | ${line}\n`);
            lineNumber++;
        });
    }
    _printJsonLog(logObject) {
        const std = logObject.logLevelId < this._minLevelToStdErr
            ? this.settings.stdOut
            : this.settings.stdErr;
        std.write(JSON.stringify(logObject) + "\n");
    }
}
exports.Logger = Logger;
//# sourceMappingURL=index.js.map